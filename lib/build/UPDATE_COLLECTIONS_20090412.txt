Index: test/com/google/inject/internal/ForwardingMap.java
===================================================================
--- test/com/google/inject/internal/ForwardingMap.java	(revision 929)
+++ test/com/google/inject/internal/ForwardingMap.java	(working copy)
@@ -16,8 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.internal.Nullable;
-
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
@@ -74,100 +72,66 @@
   }
 
   private transient Set<K> keySet;
-  
-  /**
-   * {@inheritDoc}
-   * 
-   * <p>The returned set's {@code removeAll} and {@code retainAll} methods
-   * always throw a {@link NullPointerException} when given a null collection.  
-   */
+
   public Set<K> keySet() {
     return (keySet == null) ? keySet = createKeySet() : keySet;
   }
 
   /**
    * Generates a {@link Set} for use by {@link #keySet()}.
-   * 
+   *
    * <p>ForwardingMap's implementation of keySet() calls this method to
    * generate a collection of values, and then reuses that Set
-   * for subsequent invocations.  By default, this Set is essentially the
+   * for subsequent invocations.  By default, this Set is the
    * result of invoking keySet() on the delegate.  Override this method if you
    * want to provide another implementation.
-   * 
+   *
    * @return A set for use by keySet().
    */
   protected Set<K> createKeySet() {
-    final Set<K> delegate = delegate().keySet();
-    return new ForwardingSet<K>() {
-      @Override protected Set<K> delegate() {
-        return delegate;
-      }
-    };
+    return delegate().keySet();
   }
-  
+
   private transient Collection<V> values;
 
-  /**
-   * {@inheritDoc}
-   * 
-   * <p>The returned collection's {@code removeAll} and {@code retainAll}
-   * methods always throw a {@link NullPointerException} when given a null
-   * collection.  
-   */
   public Collection<V> values() {
     return (values == null) ? values = createValues() : values;
   }
 
   /**
    * Generates a {@link Collection} for use by {@link #values()}.
-   * 
+   *
    * <p>ForwardingMap's implementation of {@code values()} calls this method to
-   * generate a collection of values, and then reuses that collection 
-   * for subsequent invocations.  By default, this collection is essentially the
+   * generate a collection of values, and then reuses that collection
+   * for subsequent invocations.  By default, this collection is the
    * result of invoking values() on the delegate.  Override this method if you
    * want to provide another implementation.
-   * 
+   *
    * @return A set for use by values().
    */
   protected Collection<V> createValues() {
-    final Collection<V> delegate = delegate().values();
-    return new ForwardingCollection<V>() {
-      @Override protected Collection<V> delegate() {
-        return delegate;
-      }      
-    };
+    return delegate().values();
   }
-  
+
   private transient Set<Entry<K, V>> entrySet;
-  
-  /**
-   * {@inheritDoc}
-   * 
-   * <p>The returned set's {@code removeAll} and {@code retainAll} methods
-   * always throw a {@link NullPointerException} when given a null collection.  
-   */
+
   public Set<Entry<K, V>> entrySet() {
     return (entrySet == null) ? entrySet = createEntrySet() : entrySet;
   }
 
   /**
    * Generates a {@link Set} for use by {@link #entrySet()}.
-   * 
+   *
    * <p>ForwardingMap's implementation of entrySet() calls this method to
    * generate a set of entries, and then reuses that set for subsequent
-   * invocations.  By default, this set is essentially the result of invoking
-   * entrySet() on the delegate.  Override this method if you want to 
+   * invocations.  By default, this set is the result of invoking
+   * entrySet() on the delegate.  Override this method if you want to
    * provide another implementation.
-   * 
+   *
    * @return A set for use by entrySet().
    */
   protected Set<Entry<K, V>> createEntrySet() {
-    final Set<Entry<K, V>> delegate = delegate().entrySet();
-    return new ForwardingSet<Entry<K, V>>() {
-      @Override protected Set<Entry<K, V>> delegate() {
-        return delegate;
-      }
-    };
+    return delegate().entrySet();
   }
 
   @Override public boolean equals(@Nullable Object object) {
Index: test/com/google/inject/internal/Predicate.java
===================================================================
--- test/com/google/inject/internal/Predicate.java	(revision 0)
+++ test/com/google/inject/internal/Predicate.java	(revision 0)
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject.internal;
+
+/**
+ * Determines a true or false value for a given input. For example, a
+ * {@code RegexPredicate} might implement {@code Predicate<String>}, and return
+ * {@code true} for any string that matches its given regular expression.
+ *
+ * <p>Implementations which may cause side effects upon evaluation are strongly
+ * encouraged to state this fact clearly in their API documentation.
+ *
+ * @author Kevin Bourrillion
+ */
+public interface Predicate<T> {
+
+  /*
+   * This interface does not extend Function<T, Boolean> because doing so would
+   * let predicates return null.
+   */
+
+  /**
+   * Applies this predicate to the given object.
+   *
+   * @param input the input that the predicate should act on
+   * @return the value of this predicate when applied to the input {@code t}
+   */
+  boolean apply(@Nullable T input);
+
+
+  /**
+   * Indicates whether some other object is equal to this {@code Predicate}.
+   * This method can return {@code true} <i>only</i> if the specified object is
+   * also a {@code Predicate} and, for every input object {@code input}, it
+   * returns exactly the same value. Thus, {@code predicate1.equals(predicate2)}
+   * implies that either {@code predicate1.apply(input)} and
+   * {@code predicate2.apply(input)} are both {@code true} or both
+   * {@code false}.
+   *
+   * <p>Note that it is always safe <i>not</i> to override
+   * {@link Object#equals}.
+   */
+  boolean equals(@Nullable Object obj);
+}

Property changes on: test/com/google/inject/internal/Predicate.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/google/inject/internal/Helpers.java
===================================================================
--- test/com/google/inject/internal/Helpers.java	(revision 0)
+++ test/com/google/inject/internal/Helpers.java	(revision 0)
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject.internal;
+
+import junit.framework.Assert;
+import junit.framework.AssertionFailedError;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Map.Entry;
+import java.util.Set;
+
+public class Helpers {
+  public static <T> T checkNotNull(T reference) {
+    if (reference == null) {
+      throw new NullPointerException();
+    }
+    return reference;
+  }
+
+  static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  public static <E> List<E> copyToList(Iterable<? extends E> elements) {
+    List<E> list = new ArrayList<E>();
+    addAll(list, elements);
+    return list;
+  }
+
+  public static <E> List<E> copyToList(E[] elements) {
+    return copyToList(Arrays.asList(elements));
+  }
+
+  public static <E> Set<E> copyToSet(Iterable<? extends E> elements) {
+    Set<E> set = new LinkedHashSet<E>();
+    addAll(set, elements);
+    return set;
+  }
+
+  public static <E> Set<E> copyToSet(E[] elements) {
+    return copyToSet(Arrays.asList(elements));
+  }
+
+  public static <K, V> Entry<K, V> mapEntry(K key, V value) {
+    return Collections.singletonMap(key, value).entrySet().iterator().next();
+  }
+
+  public static void assertEqualIgnoringOrder(
+      Iterable<?> expected, Iterable<?> actual) {
+    List<?> exp = copyToList(expected);
+    List<?> act = copyToList(actual);
+    String actString = act.toString();
+
+    // Of course we could take pains to give the complete description of the
+    // problem on any failure.
+
+    // Yeah it's n^2.
+    for (Object object : exp) {
+      if (!act.remove(object)) {
+        Assert.fail("did not contain expected element " + object + ", "
+            + "expected = " + exp + ", actual = " + actString);
+      }
+    }
+    Assert.assertTrue("unexpected elements: " + act, act.isEmpty());
+  }
+
+  public static void assertContentsAnyOrder(
+      Iterable<?> actual, Object... expected) {
+    assertEqualIgnoringOrder(Arrays.asList(expected), actual);
+  }
+
+  public static <E> boolean addAll(
+      Collection<E> addTo, Iterable<? extends E> elementsToAdd) {
+    boolean modified = false;
+    for (E e : elementsToAdd) {
+      modified |= addTo.add(e);
+    }
+    return modified;
+  }
+
+  static <T> Iterable<T> reverse(final List<T> list) {
+    return new Iterable<T>() {
+      public Iterator<T> iterator() {
+        final ListIterator<T> listIter = list.listIterator(list.size());
+        return new Iterator<T>() {
+          public boolean hasNext() {
+            return listIter.hasPrevious();
+          }
+          public T next() {
+            return listIter.previous();
+          }
+          public void remove() {
+            listIter.remove();
+          }
+        };
+      }
+    };
+  }
+
+  static <T> Iterator<T> cycle(final Iterable<T> iterable) {
+    return new Iterator<T>() {
+      Iterator<T> iterator = Collections.<T>emptySet().iterator();
+      public boolean hasNext() {
+        return true;
+      }
+      public T next() {
+        if (!iterator.hasNext()) {
+          iterator = iterable.iterator();
+        }
+        return iterator.next();
+      }
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+  }
+
+  static <T> T get(Iterator<T> iterator, int position) {
+    for (int i = 0; i < position; i++) {
+      iterator.next();
+    }
+    return iterator.next();
+  }
+
+  @SuppressWarnings("unchecked")
+  static <T> T reserialize(T object) {
+    try {
+      ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+      ObjectOutputStream out = new ObjectOutputStream(bytes);
+      out.writeObject(object);
+      ObjectInputStream in = new ObjectInputStream(
+          new ByteArrayInputStream(bytes.toByteArray()));
+      return (T) in.readObject();
+    } catch (IOException e) {
+      fail(e, e.getMessage());
+    } catch (ClassNotFoundException e) {
+      fail(e, e.getMessage());
+    }
+    throw new AssertionError("not reachable");
+  }
+
+  static void fail(Throwable cause, Object message) {
+    AssertionFailedError assertionFailedError =
+        new AssertionFailedError(String.valueOf(message));
+    assertionFailedError.initCause(cause);
+    throw assertionFailedError;
+  }
+}

Property changes on: test/com/google/inject/internal/Helpers.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/google/inject/internal/FinalizableReferenceQueueTest.java
===================================================================
--- test/com/google/inject/internal/FinalizableReferenceQueueTest.java	(revision 929)
+++ test/com/google/inject/internal/FinalizableReferenceQueueTest.java	(working copy)
@@ -1,13 +1,32 @@
+/*
+ * Copyright (C) 2005 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.google.inject.internal;
 
+import junit.framework.TestCase;
+
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.net.URL;
 import java.net.URLClassLoader;
-import junit.framework.TestCase;
 
 /**
- * @author crazybob@google.com (Bob Lee)
+ * Unit test for {@link FinalizableReferenceQueue}.
+ *
+ * @author Bob Lee
  */
 public class FinalizableReferenceQueueTest extends TestCase {
 
Index: test/com/google/inject/internal/MapMakerTestSuite.java
===================================================================
--- test/com/google/inject/internal/MapMakerTestSuite.java	(revision 929)
+++ test/com/google/inject/internal/MapMakerTestSuite.java	(working copy)
@@ -17,11 +17,11 @@
 package com.google.inject.internal;
 
 import com.google.inject.internal.CustomConcurrentHashMap.Impl;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
@@ -39,9 +39,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
  * Unit tests for MapMaker. Also less directly serves as the test suite for
@@ -49,19 +47,6 @@
  */
 public class MapMakerTestSuite extends TestCase {
 
-  public static Test suite() {
-    TestSuite suite = new TestSuite();
-
-    suite.addTestSuite(RecursiveComputationTest.class);
-    suite.addTestSuite(ReferenceMapTest.class);
-    suite.addTestSuite(ComputingTest.class);
-    suite.addTest(ReferenceCombinationTestSuite.suite());
-    suite.addTestSuite(ExpiringReferenceMapTest.class);
-    suite.addTestSuite(ExpiringComputingReferenceMapTest.class);
-
-    return suite;
-  }
-
   public static class MakerTest extends TestCase {
     public void testSizingDefaults() {
       Impl<?, ?, ?> map = makeCustomMap(new MapMaker());
@@ -86,7 +71,7 @@
     }
 
     public void testInitialCapacity_large() {
-      MapMaker maker = new MapMaker().initialCapacity(Integer.MAX_VALUE);
+      new MapMaker().initialCapacity(Integer.MAX_VALUE);
       // that the maker didn't blow up is enough;
       // don't actually create this monster!
     }
@@ -157,7 +142,7 @@
     }
 
     public void testConcurrencyLevel_large() {
-      MapMaker maker = new MapMaker().concurrencyLevel(Integer.MAX_VALUE);
+      new MapMaker().concurrencyLevel(Integer.MAX_VALUE);
       // don't actually build this beast
     }
 
@@ -228,19 +213,19 @@
     }
 
     public void testExpiration_small() {
-      MapMaker maker = new MapMaker().expiration(1, NANOSECONDS);
+      new MapMaker().expiration(1, NANOSECONDS);
       // well, it didn't blow up.
     }
 
-//    public void testExpiration_setTwice() {
-//      MapMaker maker = new MapMaker().expiration(1, HOURS);
-//      try {
-//        // even to the same value is not allowed
-//        maker.expiration(1, HOURS);
-//        fail();
-//      } catch (IllegalStateException expected) {
-//      }
-//    }
+    public void testExpiration_setTwice() {
+      MapMaker maker = new MapMaker().expiration(3600, SECONDS);
+      try {
+        // even to the same value is not allowed
+        maker.expiration(3600, SECONDS);
+        fail();
+      } catch (IllegalStateException expected) {
+      }
+    }
 
     public void testReturnsPlainConcurrentHashMapWhenPossible() {
       Map<?, ?> map = new MapMaker()
@@ -254,11 +239,7 @@
     private static Impl<?, ?, ?> makeCustomMap(MapMaker maker) {
       // Use makeComputingMap() to force it to return CCHM.Impl, not
       // ConcurrentHashMap.
-      return (Impl<?, ?, ?>) maker.makeComputingMap(new Function<Object, Object>() {
-        public Object apply(Object from) {
-          return from;
-        }
-      });
+      return (Impl<?, ?, ?>) maker.makeComputingMap(Functions.identity());
     }
   }
 
@@ -420,9 +401,9 @@
       Integer key1 = new Integer(12357);
       Integer key2 = new Integer(12357);
       map.put(key1, "a");
-      assertFalse(map.entrySet().remove(entry(key2, "a")));
+      assertFalse(map.entrySet().remove(Helpers.mapEntry(key2, "a")));
       assertEquals(1, map.size());
-      assertTrue(map.entrySet().remove(entry(key1, "a")));
+      assertTrue(map.entrySet().remove(Helpers.mapEntry(key1, "a")));
       assertEquals(0, map.size());
     }
 
@@ -453,11 +434,11 @@
       ConcurrentMap<String, Integer> map =
           new MapMaker().makeMap();
       map.put("one", 1);
-      reserializeAndAssert(map);
+      SerializableTester.reserializeAndAssert(map);
 
       map = new MapMaker().weakKeys().makeMap();
       map.put("one", 1);
-      reserialize(map);
+      SerializableTester.reserialize(map);
     }
   }
 
@@ -611,7 +592,7 @@
   /**
    * Tests combinations of key and value reference types.
    */
-  public static class ReferenceCombinationTestSuite {
+  public static class ReferenceCombinationTestSuite extends TestCase {
 
     interface BuilderOption {
       void applyTo(MapMaker maker);
@@ -783,8 +764,9 @@
         final ConcurrentMap<String, String> map = newMap();
         map.put("a", "1");
         map.put("b", "2");
+        @SuppressWarnings("unchecked")
         Set<Map.Entry<String, String>> expected
-            = set(entry("a", "1"), entry("b", "2"));
+            = set(Helpers.mapEntry("a", "1"), Helpers.mapEntry("b", "2"));
         assertEquals(expected, map.entrySet());
       }
 
@@ -837,12 +819,11 @@
         assertEquals(1, map.size());
       }
 
-      public void testReferenceMapSerialization() throws IOException,
-          ClassNotFoundException {
+      public void testReferenceMapSerialization() {
         Map<Key, Value> original = newMap();
         original.put(Key.FOO, Value.FOO);
         @SuppressWarnings("unchecked")
-        Map<Key, Value> map = reserialize(original);
+        Map<Key, Value> map = SerializableTester.reserialize(original);
         map.put(Key.BAR, Value.BAR);
         assertSame(Value.FOO, map.get(Key.FOO));
         assertSame(Value.BAR, map.get(Key.BAR));
@@ -856,15 +837,15 @@
           count++;
           return Value.valueOf(key.toString());
         }
+        private static final long serialVersionUID = 0;
       }
 
-      public void testReferenceCacheSerialization() throws IOException,
-          ClassNotFoundException {
+      public void testReferenceCacheSerialization() {
         MockFunction f = new MockFunction();
         ConcurrentMap<Object, Object> map = newBuilder().makeComputingMap(f);
         assertSame(Value.FOO, map.get(Key.FOO));
         assertSame(Value.BAR, map.get(Key.BAR));
-        map = reserialize(map);
+        map = SerializableTester.reserialize(map);
         assertSame(Value.FOO, map.get(Key.FOO));
         assertSame(Value.BAR, map.get(Key.BAR));
         assertSame(Value.TEE, map.get(Key.TEE));
@@ -937,7 +918,8 @@
 
       for (int i = 0; i < 10; i++) {
         map.putIfAbsent(KEY_PREFIX + i, VALUE_PREFIX + i);
-        assertEquals(Integer.valueOf(VALUE_PREFIX + i), map.get(KEY_PREFIX + i));
+        assertEquals(Integer.valueOf(VALUE_PREFIX + i),
+            map.get(KEY_PREFIX + i));
       }
 
       runTasks();
@@ -947,7 +929,8 @@
 
     public void testExpiringGetForSoft() {
       ConcurrentMap<String, Integer> map = new MapMaker()
-          .expiration(EXPIRING_TIME, TimeUnit.MILLISECONDS).makeMap();
+          .softValues().expiration(EXPIRING_TIME, TimeUnit.MILLISECONDS)
+          .makeMap();
 
       runExpirationTest(map);
     }
@@ -968,7 +951,8 @@
 
     public void testRemovalSchedulerForSoft() {
       ConcurrentMap<String, Integer> map = new MapMaker()
-          .softValues().expiration(EXPIRING_TIME, TimeUnit.MILLISECONDS).makeMap();
+          .softValues().expiration(EXPIRING_TIME, TimeUnit.MILLISECONDS)
+          .makeMap();
 
       runRemovalScheduler(map, KEY_PREFIX, EXPIRING_TIME);
     }
@@ -1065,7 +1049,8 @@
 
     public void testExpiringPut() {
       ConcurrentMap<String, Integer> cache = new MapMaker()
-          .expiration(50, TimeUnit.MILLISECONDS).makeComputingMap(WATCHED_CREATOR);
+          .expiration(50, TimeUnit.MILLISECONDS)
+          .makeComputingMap(WATCHED_CREATOR);
 
       for (int i = 0; i < 10; i++) {
         cache.put(KEY_PREFIX + i, i + VALUE_SUFFIX);
@@ -1088,7 +1073,8 @@
 
     public void testExpiringPutIfAbsent() {
       ConcurrentMap<String, Integer> cache = new MapMaker()
-          .expiration(50, TimeUnit.MILLISECONDS).makeComputingMap(WATCHED_CREATOR);
+          .expiration(50, TimeUnit.MILLISECONDS)
+          .makeComputingMap(WATCHED_CREATOR);
 
       for (int i = 0; i < 10; i++) {
         cache.putIfAbsent(KEY_PREFIX + i, i + VALUE_SUFFIX);
@@ -1111,7 +1097,8 @@
 
     public void testExpiringGetForStrong() {
       ConcurrentMap<String, Integer> cache = new MapMaker()
-          .expiration(10, TimeUnit.MILLISECONDS).makeComputingMap(WATCHED_CREATOR);
+          .expiration(10, TimeUnit.MILLISECONDS)
+          .makeComputingMap(WATCHED_CREATOR);
 
       runExpirationTest(cache);
     }
@@ -1232,38 +1219,6 @@
         new WatchedCreatorFunction();
   }
 
-  static <T> T reserializeAndAssert(T object) {
-    T copy = reserialize(object);
-    if (!copy.equals(object)) {
-      throw new AssertionError("The re-serialized object " + copy +
-          " does not equal the original object " + object);
-    }
-    return copy;
-  }
-
-  @SuppressWarnings("unchecked")
-  static <T> T reserialize(T object) {
-    if (object == null) {
-      throw new NullPointerException();
-    }
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    try {
-      ObjectOutputStream out = new ObjectOutputStream(bytes);
-      out.writeObject(object);
-      ObjectInputStream in = new ObjectInputStream(
-          new ByteArrayInputStream(bytes.toByteArray()));
-      return (T) in.readObject();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static <K, V> Map.Entry<K, V> entry(K key, V value) {
-    return new SimpleEntry<K, V>(key, value);
-  }
-
   static <E> Set<E> set(E... elements) {
     return new HashSet<E>(Arrays.asList(elements));
   }
Index: test/com/google/inject/internal/Functions.java
===================================================================
--- test/com/google/inject/internal/Functions.java	(revision 0)
+++ test/com/google/inject/internal/Functions.java	(revision 0)
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject.internal;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import java.io.Serializable;
+import java.util.Map;
+
+/**
+ * Useful functions.
+ *
+ * <p>All methods returns serializable functions as long as they're given
+ * serializable parameters.
+ *
+ * @author Mike Bostock
+ * @author Vlad Patryshev
+ * @author Jared Levy
+ */
+public final class Functions {
+  private Functions() {}
+
+  /**
+   * Returns a function that calls {@code toString()} on its argument. The
+   * function does not accept nulls; it will throw a
+   * {@link NullPointerException} when applied to {@code null}.
+   */
+  public static Function<Object, String> toStringFunction() {
+    return ToStringFunction.INSTANCE;
+  }
+
+  // enum singleton pattern
+  private enum ToStringFunction implements Function<Object, String> {
+    INSTANCE;
+
+    public String apply(Object o) {
+      return o.toString();
+    }
+
+    @Override public String toString() {
+      return "toString";
+    }
+  }
+
+  /**
+   * Returns the identity function.
+   */
+  @SuppressWarnings("unchecked")
+  public static <E> Function<E, E> identity() {
+    return (Function<E, E>) IdentityFunction.INSTANCE;
+  }
+
+  // enum singleton pattern
+  private enum IdentityFunction implements Function<Object, Object> {
+    INSTANCE;
+
+    public Object apply(Object o) {
+      return o;
+    }
+
+    @Override public String toString() {
+      return "identity";
+    }
+  }
+
+  /**
+   * Returns a function which performs a map lookup.
+   *
+   * <p>The difference between a map and a function is that a map is defined on
+   * a set of keys, while a function is defined on all inputs of the correct
+   * type. The function created by this method returns {@code null} for all
+   * inputs that do not belong to the map's key set.
+   *
+   * @param map source map that determines the function behavior
+   * @return function that returns {@code map.get(a)} for each {@code a}
+   */
+  public static <K, V> Function<K, V> forMap(Map<K, V> map) {
+    return new FunctionForMapNoDefault<K, V>(map);
+  }
+
+  private static class FunctionForMapNoDefault<K, V>
+      implements Function<K, V>, Serializable {
+    private final Map<K, V> map;
+
+    public FunctionForMapNoDefault(Map<K, V> map) {
+      this.map = checkNotNull(map);
+    }
+    public V apply(K a) {
+      return map.get(a);
+    }
+    @Override public boolean equals(Object o) {
+      if (o instanceof FunctionForMapNoDefault) {
+        FunctionForMapNoDefault<?, ?> that = (FunctionForMapNoDefault<?, ?>) o;
+        return map.equals(that.map);
+      }
+      return false;
+    }
+    @Override public int hashCode() {
+      return map.hashCode();
+    }
+    @Override public String toString() {
+      return "forMap(" + map + ")";
+    }
+    private static final long serialVersionUID = 0;
+  }
+
+  /**
+   * Returns a function which performs a map lookup with a default value. The
+   * function created by this method returns {@code defaultValue} for all
+   * inputs that do not belong to the map's key set.
+   *
+   * @param map source map that determines the function behavior
+   * @param defaultValue the value to return for inputs that aren't map keys
+   * @return function that returns {@code map.get(a)} when {@code a} is a key,
+   *     or {@code defaultValue} otherwise
+   */
+  public static <K, V> Function<K, V> forMap(
+      Map<K, ? extends V> map, @Nullable V defaultValue) {
+    return new ForMapWithDefault<K, V>(map, defaultValue);
+  }
+
+  private static class ForMapWithDefault<K, V>
+      implements Function<K, V>, Serializable {
+    private final Map<K, ? extends V> map;
+    private final V defaultValue;
+
+    public ForMapWithDefault(Map<K, ? extends V> map, V defaultValue) {
+      this.map = checkNotNull(map);
+      this.defaultValue = defaultValue;
+    }
+    public V apply(K a) {
+      return map.containsKey(a) ? map.get(a) : defaultValue;
+    }
+    @Override public boolean equals(Object o) {
+      if (o instanceof ForMapWithDefault) {
+        ForMapWithDefault<?, ?> that = (ForMapWithDefault<?, ?>) o;
+        return map.equals(that.map)
+            && Objects.equal(defaultValue, that.defaultValue);
+      }
+      return false;
+    }
+    @Override public int hashCode() {
+      return map.hashCode() + defaultValue.hashCode();
+    }
+    @Override public String toString() {
+      return "forMap(" + map + ", defaultValue=" + defaultValue + ")";
+    }
+    private static final long serialVersionUID = 0;
+  }
+
+  /**
+   * Returns the composition of two functions. For {@code f: A->B} and
+   * {@code g: B->C}, composition is defined as the function h such that
+   * {@code h(a) == g(f(a))} for each {@code a}.
+   *
+   * @see <a href="//en.wikipedia.org/wiki/Function_composition">
+   * function composition</a>
+   *
+   * @param g the second function to apply
+   * @param f the first function to apply
+   * @return the composition of {@code f} and {@code g}
+   */
+  public static <A, B, C> Function<A, C> compose(
+      Function<B, C> g, Function<A, ? extends B> f) {
+    return new FunctionComposition<A, B, C>(g, f);
+  }
+
+  private static class FunctionComposition<A, B, C>
+      implements Function<A, C>, Serializable {
+    private final Function<B, C> g;
+    private final Function<A, ? extends B> f;
+
+    public FunctionComposition(Function<B, C> g,
+        Function<A, ? extends B> f) {
+      this.g = checkNotNull(g);
+      this.f = checkNotNull(f);
+    }
+    public C apply(A a) {
+      return g.apply(f.apply(a));
+    }
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof FunctionComposition) {
+        FunctionComposition<?, ?, ?> that = (FunctionComposition<?, ?, ?>) obj;
+        return f.equals(that.f) && g.equals(that.g);
+      }
+      return false;
+    }
+
+    @Override public int hashCode() {
+      return f.hashCode() ^ g.hashCode();
+    }
+    @Override public String toString() {
+      return g.toString() + "(" + f.toString() + ")";
+    }
+    private static final long serialVersionUID = 0;
+  }
+
+  /**
+   * Creates a function that returns the same boolean output as the given
+   * predicate for all inputs.
+   */
+  public static <T> Function<T, Boolean> forPredicate(Predicate<T> predicate) {
+    return new PredicateFunction<T>(predicate);
+  }
+
+  /** @see Functions#forPredicate */
+  private static class PredicateFunction<T>
+      implements Function<T, Boolean>, Serializable {
+    private final Predicate<T> predicate;
+
+    private PredicateFunction(Predicate<T> predicate) {
+      this.predicate = checkNotNull(predicate);
+    }
+
+    public Boolean apply(T t) {
+      return predicate.apply(t);
+    }
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof PredicateFunction) {
+        PredicateFunction<?> that = (PredicateFunction<?>) obj;
+        return predicate.equals(that.predicate);
+      }
+      return false;
+    }
+    @Override public int hashCode() {
+      return predicate.hashCode();
+    }
+    @Override public String toString() {
+      return "forPredicate(" + predicate + ")";
+    }
+    private static final long serialVersionUID = 0;
+  }
+
+  /**
+   * Creates a function that returns {@code value} for any input.
+   *
+   * @param value the constant value for the function to return
+   * @return a function that always returns {@code value}
+   */
+  public static <E> Function<Object, E> constant(@Nullable E value) {
+    return new ConstantFunction<E>(value);
+  }
+
+  private static class ConstantFunction<E>
+      implements Function<Object, E>, Serializable {
+    private final E value;
+
+    public ConstantFunction(@Nullable E value) {
+      this.value = value;
+    }
+    public E apply(Object from) {
+      return value;
+    }
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof ConstantFunction) {
+        ConstantFunction<?> that = (ConstantFunction<?>) obj;
+        return Objects.equal(value, that.value);
+      }
+      return false;
+    }
+    @Override public int hashCode() {
+      return (value == null) ? 0 : value.hashCode();
+    }
+    @Override public String toString() {
+      return "constant(" + value + ")";
+    }
+    private static final long serialVersionUID = 0;
+  }
+}

Property changes on: test/com/google/inject/internal/Functions.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/google/inject/internal/ForwardingCollection.java
===================================================================
--- test/com/google/inject/internal/ForwardingCollection.java	(revision 929)
+++ test/com/google/inject/internal/ForwardingCollection.java	(working copy)
@@ -16,8 +16,6 @@
 
 package com.google.inject.internal;
 
-import static com.google.inject.internal.Preconditions.checkNotNull;
-
 import java.util.Collection;
 import java.util.Iterator;
 
@@ -43,14 +41,8 @@
     return delegate().size();
   }
 
-  /**
-   * {@inheritDoc}
-   * 
-   * <p>This method always throws a {@link NullPointerException} when
-   * {@code collection} is null.  
-   */
   public boolean removeAll(Collection<?> collection) {
-    return delegate().removeAll(checkNotNull(collection));
+    return delegate().removeAll(collection);
   }
 
   public boolean isEmpty() {
@@ -85,14 +77,8 @@
     return delegate().addAll(collection);
   }
 
-  /**
-   * {@inheritDoc}
-   * 
-   * <p>This method always throws a {@link NullPointerException} when
-   * {@code collection} is null.  
-   */
   public boolean retainAll(Collection<?> collection) {
-    return delegate().retainAll(checkNotNull(collection));
+    return delegate().retainAll(collection);
   }
 
   public void clear() {
Index: test/com/google/inject/internal/ForwardingSet.java
===================================================================
--- test/com/google/inject/internal/ForwardingSet.java	(revision 929)
+++ test/com/google/inject/internal/ForwardingSet.java	(working copy)
@@ -16,8 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.internal.Nullable;
-
 import java.util.Set;
 
 /**
Index: test/com/google/inject/internal/Preconditions.java
===================================================================
--- test/com/google/inject/internal/Preconditions.java	(revision 0)
+++ test/com/google/inject/internal/Preconditions.java	(revision 0)
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.base;
+
+import java.util.NoSuchElementException;
+
+/**
+ * Simple static methods to be called at the start of your own methods to verify
+ * correct arguments and state. This allows constructs such as
+ * <pre>
+ *     if (count <= 0) {
+ *       throw new IllegalArgumentException("must be positive: " + count);
+ *     }</pre>
+ *
+ * to be replaced with the more compact
+ * <pre>
+ *     checkArgument(count > 0, "must be positive: %s", count);</pre>
+ *
+ * Note that the sense of the expression is inverted; with {@code Preconditions}
+ * you declare what you expect to be <i>true</i>, just as you do with an
+ * <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/assert.html">
+ * {@code assert}</a> or a JUnit {@code assertTrue()} call.
+ *
+ * <p>Take care not to confuse precondition checking with other similar types
+ * of checks! Precondition exceptions -- including those provided here, but also
+ * {@link IndexOutOfBoundsException}, {@link NoSuchElementException}, {@link
+ * UnsupportedOperationException} and others -- are used to signal that the
+ * <i>calling method</i> has made an error. This tells the caller that it should
+ * not have invoked the method when it did, with the arguments it did, or
+ * perhaps <i>ever</i>. Postcondition or other invariant failures should not
+ * throw these types of exceptions.
+ *
+ * <p><b>Note:</b> The methods of the {@code Preconditions} class are highly
+ * unusual in one way: they are <i>supposed to</i> throw exceptions, and promise
+ * in their specifications to do so even when given perfectly valid input. That
+ * is, {@code null} is a valid parameter to the method {@link
+ * #checkNotNull(Object)} -- and technically this parameter could be even marked
+ * as {@link Nullable} -- yet the method will still throw an exception anyway,
+ * because that's what its contract says to do.
+ *
+ * @author Kevin Bourrillion
+ */
+public final class Preconditions {
+  private Preconditions() {}
+
+  /**
+   * Ensures the truth of an expression involving one or more parameters to the
+   * calling method.
+   *
+   * @param expression a boolean expression
+   * @throws IllegalArgumentException if {@code expression} is false
+   */
+  public static void checkArgument(boolean expression) {
+    if (!expression) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  /**
+   * Ensures the truth of an expression involving one or more parameters to the
+   * calling method.
+   *
+   * @param expression a boolean expression
+   * @param errorMessage the exception message to use if the check fails; will
+   *     be converted to a string using {@link String#valueOf(Object)}
+   * @throws IllegalArgumentException if {@code expression} is false
+   */
+  public static void checkArgument(boolean expression, Object errorMessage) {
+    if (!expression) {
+      throw new IllegalArgumentException(String.valueOf(errorMessage));
+    }
+  }
+
+  /**
+   * Ensures the truth of an expression involving one or more parameters to the
+   * calling method.
+   *
+   * @param expression a boolean expression
+   * @param errorMessageTemplate a template for the exception message should the
+   *     check fail. The message is formed by replacing each {@code %s}
+   *     placeholder in the template with an argument. These are matched by
+   *     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
+   *     Unmatched arguments will be appended to the formatted message in square
+   *     braces. Unmatched placeholders will be left as-is.
+   * @param errorMessageArgs the arguments to be substituted into the message
+   *     template. Arguments are converted to strings using
+   *     {@link String#valueOf(Object)}.
+   * @throws IllegalArgumentException if {@code expression} is false
+   * @throws NullPointerException if the check fails and either {@code
+   *     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
+   *     this happen)
+   */
+  public static void checkArgument(boolean expression,
+      String errorMessageTemplate, Object... errorMessageArgs) {
+    if (!expression) {
+      throw new IllegalArgumentException(
+          format(errorMessageTemplate, errorMessageArgs));
+    }
+  }
+
+  /**
+   * Ensures the truth of an expression involving the state of the calling
+   * instance, but not involving any parameters to the calling method.
+   *
+   * @param expression a boolean expression
+   * @throws IllegalStateException if {@code expression} is false
+   */
+  public static void checkState(boolean expression) {
+    if (!expression) {
+      throw new IllegalStateException();
+    }
+  }
+
+  /**
+   * Ensures the truth of an expression involving the state of the calling
+   * instance, but not involving any parameters to the calling method.
+   *
+   * @param expression a boolean expression
+   * @param errorMessage the exception message to use if the check fails; will
+   *     be converted to a string using {@link String#valueOf(Object)}
+   * @throws IllegalStateException if {@code expression} is false
+   */
+  public static void checkState(boolean expression, Object errorMessage) {
+    if (!expression) {
+      throw new IllegalStateException(String.valueOf(errorMessage));
+    }
+  }
+
+  /**
+   * Ensures the truth of an expression involving the state of the calling
+   * instance, but not involving any parameters to the calling method.
+   *
+   * @param expression a boolean expression
+   * @param errorMessageTemplate a template for the exception message should the
+   *     check fail. The message is formed by replacing each {@code %s}
+   *     placeholder in the template with an argument. These are matched by
+   *     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
+   *     Unmatched arguments will be appended to the formatted message in square
+   *     braces. Unmatched placeholders will be left as-is.
+   * @param errorMessageArgs the arguments to be substituted into the message
+   *     template. Arguments are converted to strings using
+   *     {@link String#valueOf(Object)}.
+   * @throws IllegalStateException if {@code expression} is false
+   * @throws NullPointerException if the check fails and either {@code
+   *     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
+   *     this happen)
+   */
+  public static void checkState(boolean expression,
+      String errorMessageTemplate, Object... errorMessageArgs) {
+    if (!expression) {
+      throw new IllegalStateException(
+          format(errorMessageTemplate, errorMessageArgs));
+    }
+  }
+
+  /**
+   * Ensures that an object reference passed as a parameter to the calling
+   * method is not null.
+   *
+   * @param reference an object reference
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   */
+  public static <T> T checkNotNull(T reference) {
+    if (reference == null) {
+      throw new NullPointerException();
+    }
+    return reference;
+  }
+
+  /**
+   * Ensures that an object reference passed as a parameter to the calling
+   * method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessage the exception message to use if the check fails; will
+   *     be converted to a string using {@link String#valueOf(Object)}
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   */
+  public static <T> T checkNotNull(T reference, Object errorMessage) {
+    if (reference == null) {
+      throw new NullPointerException(String.valueOf(errorMessage));
+    }
+    return reference;
+  }
+
+  /**
+   * Ensures that an object reference passed as a parameter to the calling
+   * method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessageTemplate a template for the exception message should the
+   *     check fail. The message is formed by replacing each {@code %s}
+   *     placeholder in the template with an argument. These are matched by
+   *     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
+   *     Unmatched arguments will be appended to the formatted message in square
+   *     braces. Unmatched placeholders will be left as-is.
+   * @param errorMessageArgs the arguments to be substituted into the message
+   *     template. Arguments are converted to strings using
+   *     {@link String#valueOf(Object)}.
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   */
+  public static <T> T checkNotNull(T reference, String errorMessageTemplate,
+      Object... errorMessageArgs) {
+    if (reference == null) {
+      // If either of these parameters is null, the right thing happens anyway
+      throw new NullPointerException(
+          format(errorMessageTemplate, errorMessageArgs));
+    }
+    return reference;
+  }
+
+  /**
+   * Ensures that {@code index} specifies a valid <i>element</i> in an array,
+   * list or string of size {@code size}. An element index may range from zero,
+   * inclusive, to {@code size}, exclusive.
+   *
+   * @param index a user-supplied index identifying an element of an array, list
+   *     or string
+   * @param size the size of that array, list or string
+   * @throws IndexOutOfBoundsException if {@code index} is negative or is not
+   *     less than {@code size}
+   * @throws IllegalArgumentException if {@code size} is negative
+   */
+  public static void checkElementIndex(int index, int size) {
+    checkElementIndex(index, size, "index");
+  }
+
+  /**
+   * Ensures that {@code index} specifies a valid <i>element</i> in an array,
+   * list or string of size {@code size}. An element index may range from zero,
+   * inclusive, to {@code size}, exclusive.
+   *
+   * @param index a user-supplied index identifying an element of an array, list
+   *     or string
+   * @param size the size of that array, list or string
+   * @param desc the text to use to describe this index in an error message
+   * @throws IndexOutOfBoundsException if {@code index} is negative or is not
+   *     less than {@code size}
+   * @throws IllegalArgumentException if {@code size} is negative
+   */
+  public static void checkElementIndex(int index, int size, String desc) {
+    if (size < 0) {
+      throw new IllegalArgumentException("negative size: " + size);
+    }
+    if (index < 0) {
+      throw new IndexOutOfBoundsException(
+          format("%s (%s) must not be negative", desc, index));
+    }
+    if (index >= size) {
+      throw new IndexOutOfBoundsException(
+          format("%s (%s) must be less than size (%s)", desc, index, size));
+    }
+  }
+
+  /**
+   * Ensures that {@code index} specifies a valid <i>position</i> in an array,
+   * list or string of size {@code size}. A position index may range from zero
+   * to {@code size}, inclusive.
+   *
+   * @param index a user-supplied index identifying a position in an array, list
+   *     or string
+   * @param size the size of that array, list or string
+   * @throws IndexOutOfBoundsException if {@code index} is negative or is
+   *     greater than {@code size}
+   * @throws IllegalArgumentException if {@code size} is negative
+   */
+  public static void checkPositionIndex(int index, int size) {
+    checkPositionIndex(index, size, "index");
+  }
+
+  /**
+   * Ensures that {@code index} specifies a valid <i>position</i> in an array,
+   * list or string of size {@code size}. A position index may range from zero
+   * to {@code size}, inclusive.
+   *
+   * @param index a user-supplied index identifying a position in an array, list
+   *     or string
+   * @param size the size of that array, list or string
+   * @param desc the text to use to describe this index in an error message
+   * @throws IndexOutOfBoundsException if {@code index} is negative or is
+   *     greater than {@code size}
+   * @throws IllegalArgumentException if {@code size} is negative
+   */
+  public static void checkPositionIndex(int index, int size, String desc) {
+    if (size < 0) {
+      throw new IllegalArgumentException("negative size: " + size);
+    }
+    if (index < 0) {
+      throw new IndexOutOfBoundsException(format(
+          "%s (%s) must not be negative", desc, index));
+    }
+    if (index > size) {
+      throw new IndexOutOfBoundsException(format(
+          "%s (%s) must not be greater than size (%s)", desc, index, size));
+    }
+  }
+
+  /**
+   * Ensures that {@code start} and {@code end} specify a valid <i>positions</i>
+   * in an array, list or string of size {@code size}, and are in order. A
+   * position index may range from zero to {@code size}, inclusive.
+   *
+   * @param start a user-supplied index identifying a starting position in an
+   *     array, list or string
+   * @param end a user-supplied index identifying a ending position in an array,
+   *     list or string
+   * @param size the size of that array, list or string
+   * @throws IndexOutOfBoundsException if either index is negative or is
+   *     greater than {@code size}, or if {@code end} is less than {@code start}
+   * @throws IllegalArgumentException if {@code size} is negative
+   */
+  public static void checkPositionIndexes(int start, int end, int size) {
+    checkPositionIndex(start, size, "start index");
+    checkPositionIndex(end, size, "end index");
+    if (end < start) {
+      throw new IndexOutOfBoundsException(format(
+          "end index (%s) must not be less than start index (%s)", end, start));
+    }
+  }
+
+  /**
+   * Substitutes each {@code %s} in {@code template} with an argument. These
+   * are matched by position - the first {@code %s} gets {@code args[0]}, etc.
+   * If there are more arguments than placeholders, the unmatched arguments will
+   * be appended to the end of the formatted message in square braces.
+   *
+   * @param template a non-null string containing 0 or more {@code %s}
+   *     placeholders.
+   * @param args the arguments to be substituted into the message
+   *     template. Arguments are converted to strings using
+   *     {@link String#valueOf(Object)}. Arguments can be null.
+   */
+  static String format(String template, Object... args) {
+    // start substituting the arguments into the '%s' placeholders
+    StringBuilder builder = new StringBuilder(
+        template.length() + 16 * args.length);
+    int templateStart = 0;
+    int i = 0;
+    while (i < args.length) {
+      int placeholderStart = template.indexOf("%s", templateStart);
+      if (placeholderStart == -1) {
+        break;
+      }
+      builder.append(template.substring(templateStart, placeholderStart));
+      builder.append(args[i++]);
+      templateStart = placeholderStart + 2;
+    }
+    builder.append(template.substring(templateStart));
+
+    // if we run out of placeholders, append the extra args in square braces
+    if (i < args.length) {
+      builder.append(" [");
+      builder.append(args[i++]);
+      while (i < args.length) {
+        builder.append(", ");
+        builder.append(args[i++]);
+      }
+      builder.append("]");
+    }
+
+    return builder.toString();
+  }
+}

Property changes on: test/com/google/inject/internal/Preconditions.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/google/inject/internal/ForwardingObject.java
===================================================================
--- test/com/google/inject/internal/ForwardingObject.java	(revision 929)
+++ test/com/google/inject/internal/ForwardingObject.java	(working copy)
@@ -50,7 +50,7 @@
 
   /** Sole constructor. */
   protected ForwardingObject() {}
-  
+
   /**
    * Returns the backing delegate instance that methods are forwarded to.
    * Abstract subclasses generally override the {@link ForwardingObject} method
@@ -67,6 +67,6 @@
   @Override public String toString() {
     return delegate().toString();
   }
-  
+
   /* No equals or hashCode. See class comments for details. */
 }
Index: test/com/google/inject/internal/SerializationException.java
===================================================================
--- test/com/google/inject/internal/SerializationException.java	(revision 0)
+++ test/com/google/inject/internal/SerializationException.java	(revision 0)
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject.internal;
+
+/**
+ * Exception thrown when an object fails to serialize or deserialize.
+ *
+ * @see SerializableTester
+ * @author Mike Bostock
+ */
+public class SerializationException extends RuntimeException {
+  public SerializationException(Throwable cause) {
+    super(cause);
+  }
+  public SerializationException(String message, Throwable cause) {
+    super(message, cause);
+  }
+  private static final long serialVersionUID = 0;
+}

Property changes on: test/com/google/inject/internal/SerializationException.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/google/inject/internal/Jsr166HashMapTest.java
===================================================================
--- test/com/google/inject/internal/Jsr166HashMapTest.java	(revision 929)
+++ test/com/google/inject/internal/Jsr166HashMapTest.java	(working copy)
@@ -27,6 +27,7 @@
  * ConcurrentHashMap tests copied from ConcurrentHashMapTest. Useful as a
  * test case for CustomConcurrentHashMap.
  */
+@SuppressWarnings("unchecked")
 public class Jsr166HashMapTest extends TestCase {
 
     /*
@@ -575,6 +576,7 @@
     /**
      * A deserialized map equals original
      */
+    // TODO: why not use SerializableTester?
     public void testSerialization() {
         Jsr166HashMap q = map5();
 
Index: test/com/google/inject/internal/Jsr166HashMap.java
===================================================================
--- test/com/google/inject/internal/Jsr166HashMap.java	(revision 929)
+++ test/com/google/inject/internal/Jsr166HashMap.java	(working copy)
@@ -8,6 +8,8 @@
 
 package com.google.inject.internal;
 
+import com.google.inject.internal.CustomConcurrentHashMap.SimpleStrategy;
+
 import java.io.Serializable;
 import java.util.Map;
 import java.util.concurrent.ConcurrentMap;
@@ -19,47 +21,11 @@
  */
 public class Jsr166HashMap<K, V> extends ForwardingConcurrentMap<K, V>
     implements Serializable {
-
-  static class ConcurrentHashMapStrategy<K, V>
-      implements CustomConcurrentHashMap.Strategy<K, V,
-      InternalEntry<K, V>>, Serializable {
-    public InternalEntry<K, V> newEntry(K key, int hash,
-        InternalEntry<K, V> next) {
-      return new InternalEntry<K,V>(key, hash, null, next);
-    }
-    public InternalEntry<K, V> copyEntry(K key,
-        InternalEntry<K, V> original, InternalEntry<K, V> next) {
-      return new InternalEntry<K, V>(key, original.hash, original.value, next);
-    }
-    public void setValue(InternalEntry<K, V> entry, V value) {
-      entry.value = value;
-    }
-    public V getValue(InternalEntry<K, V> entry) { return entry.value; }
-    public boolean equalKeys(K a, Object b) { return a.equals(b); }
-    public boolean equalValues(V a, Object b) { return a.equals(b); }
-    public int hashKey(Object key) { return key.hashCode(); }
-    public K getKey(InternalEntry<K, V> entry) { return entry.key; }
-    public InternalEntry<K, V> getNext(InternalEntry<K, V> entry) {
-      return entry.next;
-    }
-    public int getHash(InternalEntry<K, V> entry) { return entry.hash; }
-    public void setInternals(CustomConcurrentHashMap.Internals<K, V,
-        InternalEntry<K, V>> internals) {} // ignored
+  private static class Strategy<K, V> extends SimpleStrategy<K, V>
+      implements Serializable {
+    private static final long serialVersionUID = 0;
   }
 
-  static class InternalEntry<K, V> {
-    final K key;
-    final int hash;
-    final InternalEntry<K, V> next;
-    volatile V value;
-    InternalEntry(K key, int hash, V value, InternalEntry<K, V> next) {
-      this.key = key;
-      this.hash = hash;
-      this.value = value;
-      this.next = next;
-    }
-  }
-
   /* ---------------- Public operations -------------- */
 
   /**
@@ -110,7 +76,7 @@
         .initialCapacity(initialCapacity)
         .loadFactor(loadFactor)
         .concurrencyLevel(concurrencyLevel)
-        .buildMap(new ConcurrentHashMapStrategy<K, V>());
+        .buildMap(new Strategy<K, V>());
   }
 
   /**
Index: test/com/google/inject/internal/SerializableTester.java
===================================================================
--- test/com/google/inject/internal/SerializableTester.java	(revision 0)
+++ test/com/google/inject/internal/SerializableTester.java	(revision 0)
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject.internal;
+
+import static com.google.inject.internal.Preconditions.checkNotNull;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+/**
+ * Helper class for testing whether a class is serializable.
+ *
+ * <p>Unlike {@link com.google.common.util.SerializationChecker}, this class
+ * tests not only whether serialization succeeds, but also whether the
+ * serialized form is <i>correct</i>: i.e., whether an equivalent object can be
+ * reconstructed by <i>deserializing</i> the serialized form.
+ *
+ * <p>If serialization fails, you can use {@code SerializationChecker} to
+ * diagnose which referenced fields were not serializable.
+ *
+ * @see java.io.Serializable
+ * @author Mike Bostock
+ */
+public final class SerializableTester {
+  private SerializableTester() {}
+
+  /**
+   * Serializes and deserializes the specified object.
+   *
+   * <p>Note that the specified object may not be known by the compiler to be a
+   * {@link java.io.Serializable} instance, and is thus declared an
+   * {@code Object}. For example, it might be declared as a {@code List}.
+   *
+   * @return the re-serialized object
+   * @throws SerializationException if the specified object was not successfully
+   *     serialized or deserialized
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> T reserialize(T object) {
+    checkNotNull(object);
+    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+    try {
+      ObjectOutputStream out = new ObjectOutputStream(bytes);
+      out.writeObject(object);
+      ObjectInputStream in = new ObjectInputStream(
+          new ByteArrayInputStream(bytes.toByteArray()));
+      return (T) in.readObject();
+    } catch (RuntimeException e) {
+      throw new SerializationException(e);
+    } catch (IOException e) {
+      throw new SerializationException(e);
+    } catch (ClassNotFoundException e) {
+      throw new SerializationException(e);
+    }
+  }
+
+  /**
+   * Serializes and deserializes the specified object and verifies that the
+   * re-serialized object is equal to the provided object.
+   *
+   * <p>Note that the specified object may not be known by the compiler to be a
+   * {@link java.io.Serializable} instance, and is thus declared an
+   * {@code Object}. For example, it might be declared as a {@code List}.
+   *
+   * @return the re-serialized object
+   * @throws SerializationException if the specified object was not successfully
+   *     serialized or deserialized
+   * @throws AssertionError if the re-serialized object is not equal to the
+   *     original object
+   */
+  public static <T> T reserializeAndAssert(T object) {
+    T copy = reserialize(object);
+    if (!copy.equals(object)) {
+      throw new AssertionError("The re-serialized object " + copy +
+          " does not equal the original object " + object);
+    }
+    return copy;
+  }
+}

Property changes on: test/com/google/inject/internal/SerializableTester.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: test/com/google/inject/AllTests.java
===================================================================
--- test/com/google/inject/AllTests.java	(revision 929)
+++ test/com/google/inject/AllTests.java	(working copy)
@@ -87,7 +87,7 @@
     suite.addTestSuite(FinalizableReferenceQueueTest.class);
     suite.addTestSuite(Jsr166HashMapTest.class);
     suite.addTestSuite(LineNumbersTest.class);
-    suite.addTest(MapMakerTestSuite.suite());
+    suite.addTest(MapMakerTestSuite.ReferenceCombinationTestSuite.suite());
     suite.addTestSuite(UniqueAnnotationsTest.class);
 
     // matcher
Index: copy.sh
===================================================================
--- copy.sh	(revision 929)
+++ copy.sh	(working copy)
@@ -1,7 +1,7 @@
 #!/bin/sh
 # Copies classes into Guice's internal package.
 
-client=/usr/local/google/clients/collect/google3
+client=../google-collections
 
 srcdir=src/com/google/inject/internal
 testdir=test/com/google/inject/internal
@@ -20,7 +20,7 @@
   filter < $client/${inFile} > $destpath
 }
 
-commonpath=java/com/google/common
+commonpath=src/com/google/common
 
 copy $commonpath/collect/ComputationException.java $srcdir
 copy $commonpath/collect/AsynchronousComputationException.java $srcdir
@@ -37,7 +37,7 @@
 copy $commonpath/base/FinalizableSoftReference.java $srcdir
 copy $commonpath/base/FinalizablePhantomReference.java $srcdir
 
-commontestspath=javatests/com/google/common
+commontestspath=test/com/google/common
 
 copy $commontestspath/base/FinalizableReferenceQueueTest.java $testdir
 copy $commontestspath/collect/MapMakerTestSuite.java $testdir
Index: src/com/google/inject/internal/NullOutputException.java
===================================================================
--- src/com/google/inject/internal/NullOutputException.java	(revision 929)
+++ src/com/google/inject/internal/NullOutputException.java	(working copy)
@@ -27,4 +27,5 @@
   public NullOutputException(String s) {
     super(s);
   }
+  private static final long serialVersionUID = 0;
 }
Index: src/com/google/inject/internal/FinalizableSoftReference.java
===================================================================
--- src/com/google/inject/internal/FinalizableSoftReference.java	(revision 929)
+++ src/com/google/inject/internal/FinalizableSoftReference.java	(working copy)
@@ -37,5 +37,6 @@
   protected FinalizableSoftReference(T referent,
       FinalizableReferenceQueue queue) {
     super(referent, queue.queue);
+    queue.cleanUp();
   }
 }
Index: src/com/google/inject/internal/Finalizer.java
===================================================================
--- src/com/google/inject/internal/Finalizer.java	(revision 929)
+++ src/com/google/inject/internal/Finalizer.java	(working copy)
@@ -16,13 +16,14 @@
 
 package com.google.inject.internal;
 
-import java.util.logging.Logger;
-import java.util.logging.Level;
+import java.lang.ref.PhantomReference;
+import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
-import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
-import java.lang.ref.PhantomReference;
+import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * Thread that finalizes referents. All references should implement
@@ -87,6 +88,9 @@
   private final PhantomReference<Object> frqReference;
   private final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();
 
+  private static final Field inheritableThreadLocals
+      = getInheritableThreadLocalsField();
+
   /** Constructs a new finalizer thread. */
   private Finalizer(Class<?> finalizableReferenceClass, Object frq) {
     super(Finalizer.class.getName());
@@ -99,6 +103,15 @@
 
     setDaemon(true);
 
+    try {
+      if (inheritableThreadLocals != null) {
+        inheritableThreadLocals.set(this, null);
+      }
+    } catch (Throwable t) {
+      logger.log(Level.INFO, "Failed to clear thread local values inherited"
+          + " by reference finalizer thread.", t);
+    }
+
     // TODO: Priority?
   }
 
@@ -174,6 +187,20 @@
     }
   }
 
+  public static Field getInheritableThreadLocalsField() {
+    try {
+      Field inheritableThreadLocals
+          = Thread.class.getDeclaredField("inheritableThreadLocals");
+      inheritableThreadLocals.setAccessible(true);
+      return inheritableThreadLocals;
+    } catch (Throwable t) {
+      logger.log(Level.INFO, "Couldn't access Thread.inheritableThreadLocals."
+          + " Reference finalizer threads will inherit thread local"
+          + " values.");
+      return null;
+    }
+  }
+
   /** Indicates that it's time to shut down the Finalizer. */
   @SuppressWarnings("serial") // Never serialized or thrown out of this class.
   private static class ShutDown extends Exception { }
Index: src/com/google/inject/internal/AsynchronousComputationException.java
===================================================================
--- src/com/google/inject/internal/AsynchronousComputationException.java	(revision 929)
+++ src/com/google/inject/internal/AsynchronousComputationException.java	(working copy)
@@ -22,8 +22,8 @@
  * @author Bob Lee
  */
 public class AsynchronousComputationException extends ComputationException {
-
   public AsynchronousComputationException(Throwable cause) {
     super(cause);
   }
+  private static final long serialVersionUID = 0;
 }
Index: src/com/google/inject/internal/MapMaker.java
===================================================================
--- src/com/google/inject/internal/MapMaker.java	(revision 929)
+++ src/com/google/inject/internal/MapMaker.java	(working copy)
@@ -16,8 +16,13 @@
 
 package com.google.inject.internal;
 
+import com.google.inject.internal.FinalizableReferenceQueue;
+import com.google.inject.internal.FinalizableSoftReference;
+import com.google.inject.internal.FinalizableWeakReference;
+import com.google.inject.internal.Function;
 import com.google.inject.internal.CustomConcurrentHashMap.ComputingStrategy;
 import com.google.inject.internal.CustomConcurrentHashMap.Internals;
+
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -51,7 +56,7 @@
  *
  * These features are all optional; {@code new MapMaker().makeMap()}
  * returns a valid concurrent map that behaves exactly like a
- * {@link ConcurrentHashMap}.   
+ * {@link ConcurrentHashMap}.
  *
  * The returned map is implemented as a hash table with similar performance
  * characteristics to {@link ConcurrentHashMap}. It supports all optional
@@ -74,7 +79,7 @@
  * <p>An entry whose key or value is reclaimed by the garbage collector
  * immediately disappears from the map. (If the default settings of strong
  * keys and strong values are used, this will never happen.) The client can
- * never observe a partially-reclaimed entry. Any {@link Map.Entry}
+ * never observe a partially-reclaimed entry. Any {@link java.util.Map.Entry}
  * instance retrieved from the map's {@linkplain Map#entrySet() entry set}
  * is snapshot of that entry's state at the time of retrieval.
  *
@@ -129,7 +134,7 @@
     return this;
   }
 
-  /**C
+  /**
    * Guides the allowed concurrency among update operations. Used as a
    * hint for internal sizing. The table is internally partitioned to try
    * to permit the indicated number of concurrent updates without
@@ -254,17 +259,38 @@
             builder.loadFactor, builder.concurrencyLevel);
   }
 
-  // TODO: Clone the referenced doc here after things stabilize more so
-  // we don't expose this implementation detail.
   /**
-   * See {@link CustomConcurrentHashMap.Builder#buildComputingMap(
-   * CustomConcurrentHashMap.ComputingStrategy, Function)}.
+   * Builds a map that supports atomic, on-demand computation of values. {@link
+   * Map#get} returns the value corresponding to the given key, atomically
+   * computes it using the computer function passed to this builder, or waits
+   * for another thread to compute the value if necessary. Only one value will
+   * be computed for each key at a given time.
    *
-   * <p>If {@link java.util.Map#put} is called before a computation
-   * completes, other threads waiting on the computation will wake up and
-   * return the put value up until the computation completes, at which
-   * point the computation result will overwrite the value from the
-   * {@code put} in the map.
+   * <p>If an entry's value has not finished computing yet, query methods
+   * besides {@link java.util.Map#get} return immediately as if an entry doesn't
+   * exist. In other words, an entry isn't externally visible until the value's
+   * computation completes.
+   *
+   * <p>{@link Map#get} in the returned map implementation throws:
+   *
+   * <ul>
+   * <li>{@link NullPointerException} if the key is null or the computer returns
+   *     null</li>
+   * <li>or {@link ComputationException} wrapping an exception thrown by the
+   *     computation</li>
+   * </ul>
+   *
+   * <p><b>Note:</b> Callers of {@code get()} <i>must</i> ensure that the key
+   * argument is of type {@code K}. {@code Map.get()} takes {@code Object}, so
+   * the key type is not checked at compile time. Passing an object of a type
+   * other than {@code K} can result in that object being unsafely passed to the
+   * computer function as type {@code K} not to mention the unsafe key being
+   * stored in the map.
+   *
+   * <p>If {@link java.util.Map#put} is called before a computation completes,
+   * other threads waiting on the computation will wake up and return the put
+   * value up until the computation completes, at which point the computation
+   * result will overwrite the value from the {@code put} in the map.
    */
   public <K, V> ConcurrentMap<K, V> makeComputingMap(
       Function<? super K, ? extends V> computer) {
@@ -1018,7 +1044,7 @@
       return new SoftValueReference<K, V>(get(), entry);
     }
 
-    public V waitForValue() throws InterruptedException {
+    public V waitForValue() {
       return get();
     }
   }
@@ -1041,7 +1067,7 @@
       return this;
     }
 
-    public V waitForValue() throws InterruptedException {
+    public V waitForValue() {
       return get();
     }
   }
Index: src/com/google/inject/internal/FinalizableReferenceQueue.java
===================================================================
--- src/com/google/inject/internal/FinalizableReferenceQueue.java	(revision 929)
+++ src/com/google/inject/internal/FinalizableReferenceQueue.java	(working copy)
@@ -16,15 +16,15 @@
 
 package com.google.inject.internal;
 
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.io.IOException;
-import java.io.FileNotFoundException;
 
 /**
  * A reference queue with an associated background thread that dequeues
@@ -108,23 +108,63 @@
   final ReferenceQueue<Object> queue;
 
   /**
+   * Whether or not the background thread started successfully.
+   */
+  final boolean threadStarted;
+
+  /**
    * Constructs a new queue.
    */
   @SuppressWarnings("unchecked")
   public FinalizableReferenceQueue() {
     // We could start the finalizer lazily, but I'd rather it blow up early.
+    ReferenceQueue<Object> queue;
+    boolean threadStarted = false;
     try {
-      this.queue = (ReferenceQueue<Object>) startFinalizer.invoke(null,
+      queue = (ReferenceQueue<Object>) startFinalizer.invoke(null,
           FinalizableReference.class, this);
+      threadStarted = true;
     } catch (IllegalAccessException e) {
       // Finalizer.startFinalizer() is public.
       throw new AssertionError(e);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(e);
+    } catch (Throwable t) {
+      logger.log(Level.INFO, "Failed to start reference finalizer thread."
+          + " Reference cleanup will only occur when new references are"
+          + " created.", t);
+      queue = new ReferenceQueue<Object>();
     }
+
+    this.queue = queue;
+    this.threadStarted = threadStarted;
   }
 
   /**
+   * Repeatedly dequeues references from the queue and invokes
+   * {@link FinalizableReference#finalizeReferent()} on them until the queue
+   * is empty. This method is a no-op if the background thread was created
+   * successfully.
+   */
+  void cleanUp() {
+    if (threadStarted) {
+      return;
+    }
+
+    Reference<?> reference;
+    while ((reference = queue.poll()) != null) {
+      /*
+       * This is for the benefit of phantom references. Weak and soft
+       * references will have already been cleared by this point.
+       */
+      reference.clear();
+      try {
+        ((FinalizableReference) reference).finalizeReferent();
+      } catch (Throwable t) {
+        logger.log(Level.SEVERE, "Error cleaning up after reference.", t);
+      }
+    }
+  }
+
+  /**
    * Iterates through the given loaders until it finds one that can load
    * Finalizer.
    *
Index: src/com/google/inject/internal/FinalizableReference.java
===================================================================
--- src/com/google/inject/internal/FinalizableReference.java	(revision 929)
+++ src/com/google/inject/internal/FinalizableReference.java	(working copy)
@@ -27,7 +27,9 @@
 
   /**
    * Invoked on a background thread after the referent has been garbage
-   * collected.
+   * collected unless security restictions prevented starting a background
+   * thread, in which case this method is invoked when new references
+   * are created.
    */
   void finalizeReferent();
 }
Index: src/com/google/inject/internal/FinalizableWeakReference.java
===================================================================
--- src/com/google/inject/internal/FinalizableWeakReference.java	(revision 929)
+++ src/com/google/inject/internal/FinalizableWeakReference.java	(working copy)
@@ -37,5 +37,6 @@
   protected FinalizableWeakReference(T referent,
       FinalizableReferenceQueue queue) {
     super(referent, queue.queue);
+    queue.cleanUp();
   }
 }
Index: src/com/google/inject/internal/CustomConcurrentHashMap.java
===================================================================
--- src/com/google/inject/internal/CustomConcurrentHashMap.java	(revision 929)
+++ src/com/google/inject/internal/CustomConcurrentHashMap.java	(working copy)
@@ -16,6 +16,8 @@
 
 package com.google.inject.internal;
 
+import com.google.inject.internal.Function;
+
 import java.io.IOException;
 import java.io.Serializable;
 import java.lang.reflect.Array;
@@ -28,6 +30,7 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.concurrent.locks.ReentrantLock;
@@ -40,7 +43,8 @@
  * provides the surrounding concurrent data structure which implements {@link
  * ConcurrentMap}. Additionally supports implementing maps where {@link
  * Map#get} atomically computes values on demand (see {@link
- * Builder#buildComputingMap(CustomConcurrentHashMap.ComputingStrategy, Function)}).
+ * Builder#buildComputingMap(CustomConcurrentHashMap.ComputingStrategy,
+ * Function)}).
  *
  * <p>The resulting hash table supports full concurrency of retrievals and
  * adjustable expected concurrency for updates. Even though all operations are
@@ -121,7 +125,7 @@
  * @author Bob Lee
  * @author Doug Lea
  */
-public final class CustomConcurrentHashMap {
+final class CustomConcurrentHashMap {
 
   /** Prevents instantiation. */
   private CustomConcurrentHashMap() {}
@@ -129,7 +133,7 @@
   /**
    * Builds a custom concurrent hash map.
    */
-  public final static class Builder {
+  final static class Builder {
 
     float loadFactor = 0.75f;
     int initialCapacity = 16;
@@ -289,7 +293,7 @@
      * Constructs a new entry for the given key with a pointer to the given
      * next entry.
      *
-     * <p>This method may return different entry implementations 
+     * <p>This method may return different entry implementations
      * depending upon whether next is null or not. For example, if next is
      * null (as will often be the case), this factory might use an entry
      * class that doesn't waste memory on an unnecessary field.
@@ -342,7 +346,7 @@
      *
      * @param a key from inside the map
      * @param b key passed from caller, not necesarily of type K
-     * 
+     *
      * @see Object#equals the same contractual obligations apply here
      */
     boolean equalKeys(K a, Object b);
@@ -439,7 +443,7 @@
      *
      * @throws NullPointerException if entry is null
      */
-    boolean removeEntry(E entry, V value);
+    boolean removeEntry(E entry, @Nullable V value);
 
     /**
      * Removes the given entry from the map.
@@ -462,7 +466,8 @@
    * throw {@link UnsupportedOperationException} in {@link #setValue(Object,
    * Object)} if they wish to prevent users from setting values directly.
    *
-   * @see Builder#buildComputingMap(ComputingStrategy, Function)
+   * @see Builder#buildComputingMap(CustomConcurrentHashMap.ComputingStrategy,
+   *     Function)
    */
   public interface ComputingStrategy<K, V, E> extends Strategy<K, V, E> {
 
@@ -686,6 +691,7 @@
      * ReentrantLock opportunistically, just to simplify some locking and avoid
      * separate construction.
      */
+    @SuppressWarnings("serial") // This class is never serialized.
     final class Segment extends ReentrantLock {
 
       /*
@@ -852,7 +858,7 @@
             }
           }
         }
-        
+
         return false;
       }
 
@@ -1213,7 +1219,7 @@
      *
      * @return {@code true} if this map contains no key-value mappings
      */
-    public boolean isEmpty() {
+    @Override public boolean isEmpty() {
       final Segment[] segments = this.segments;
       /*
        * We keep track of per-segment modCounts to avoid ABA
@@ -1254,7 +1260,7 @@
      *
      * @return the number of key-value mappings in this map
      */
-    public int size() {
+    @Override public int size() {
       final Segment[] segments = this.segments;
       long sum = 0;
       long check = 0;
@@ -1312,7 +1318,7 @@
      *
      * @throws NullPointerException if the specified key is null
      */
-    public V get(Object key) {
+    @Override public V get(Object key) {
       if (key == null) {
         throw new NullPointerException("key");
       }
@@ -1329,7 +1335,7 @@
      *         {@code false} otherwise.
      * @throws NullPointerException if the specified key is null
      */
-    public boolean containsKey(Object key) {
+    @Override public boolean containsKey(Object key) {
       if (key == null) {
         throw new NullPointerException("key");
       }
@@ -1347,7 +1353,7 @@
      *         value
      * @throws NullPointerException if the specified value is null
      */
-    public boolean containsValue(Object value) {
+    @Override public boolean containsValue(Object value) {
       if (value == null) {
         throw new NullPointerException("value");
       }
@@ -1416,7 +1422,7 @@
      *         if there was no mapping for {@code key}
      * @throws NullPointerException if the specified key or value is null
      */
-    public V put(K key, V value) {
+    @Override public V put(K key, V value) {
       if (key == null) {
         throw new NullPointerException("key");
       }
@@ -1452,7 +1458,7 @@
      *
      * @param m mappings to be stored in this map
      */
-    public void putAll(Map<? extends K, ? extends V> m) {
+    @Override public void putAll(Map<? extends K, ? extends V> m) {
       for (Entry<? extends K, ? extends V> e : m.entrySet()) {
         put(e.getKey(), e.getValue());
       }
@@ -1467,7 +1473,7 @@
      *         if there was no mapping for {@code key}
      * @throws NullPointerException if the specified key is null
      */
-    public V remove(Object key) {
+    @Override public V remove(Object key) {
       if (key == null) {
         throw new NullPointerException("key");
       }
@@ -1528,7 +1534,7 @@
     /**
      * Removes all of the mappings from this map.
      */
-    public void clear() {
+    @Override public void clear() {
       for (Segment segment : segments) {
         segment.clear();
       }
@@ -1551,7 +1557,7 @@
      * iterator, and may (but is not guaranteed to) reflect any modifications
      * subsequent to construction.
      */
-    public Set<K> keySet() {
+    @Override public Set<K> keySet() {
       Set<K> ks = keySet;
       return (ks != null) ? ks : (keySet = new KeySet());
     }
@@ -1573,7 +1579,7 @@
      * iterator, and may (but is not guaranteed to) reflect any modifications
      * subsequent to construction.
      */
-    public Collection<V> values() {
+    @Override public Collection<V> values() {
       Collection<V> vs = values;
       return (vs != null) ? vs : (values = new Values());
     }
@@ -1733,13 +1739,23 @@
      * Custom Entry class used by EntryIterator.next(), that relays setValue
      * changes to the underlying map.
      */
-    final class WriteThroughEntry
-        extends SimpleEntry<K, V> {
+    final class WriteThroughEntry extends AbstractMapEntry<K, V> {
+      final K key;
+      V value;
 
-      WriteThroughEntry(K k, V v) {
-        super(k, v);
+      WriteThroughEntry(K key, V value) {
+        this.key = key;
+        this.value = value;
       }
 
+      public K getKey() {
+        return key;
+      }
+
+      public V getValue() {
+        return value;
+      }
+
       /**
        * Set our entry's value and write through to the map. The value to
        * return is somewhat arbitrary here. Since a WriteThroughEntry does not
@@ -1748,14 +1764,13 @@
        * removed in which case the put will re-establish). We do not and
        * cannot guarantee more.
        */
-      @Override
-      public V setValue(V value) {
+      @Override public V setValue(V value) {
         if (value == null) {
           throw new NullPointerException();
         }
-        V v = super.setValue(value);
-        Impl.this.put(getKey(), value);
-        return v;
+        V oldValue = Impl.this.put(getKey(), value);
+        this.value = value;
+        return oldValue;
       }
     }
 
@@ -1777,19 +1792,19 @@
         return Impl.this.size();
       }
 
-      public boolean isEmpty() {
+      @Override public boolean isEmpty() {
         return Impl.this.isEmpty();
       }
 
-      public boolean contains(Object o) {
+      @Override public boolean contains(Object o) {
         return Impl.this.containsKey(o);
       }
 
-      public boolean remove(Object o) {
+      @Override public boolean remove(Object o) {
         return Impl.this.remove(o) != null;
       }
 
-      public void clear() {
+      @Override public void clear() {
         Impl.this.clear();
       }
     }
@@ -1804,15 +1819,15 @@
         return Impl.this.size();
       }
 
-      public boolean isEmpty() {
+      @Override public boolean isEmpty() {
         return Impl.this.isEmpty();
       }
 
-      public boolean contains(Object o) {
+      @Override public boolean contains(Object o) {
         return Impl.this.containsValue(o);
       }
 
-      public void clear() {
+      @Override public void clear() {
         Impl.this.clear();
       }
     }
@@ -1823,7 +1838,7 @@
         return new EntryIterator();
       }
 
-      public boolean contains(Object o) {
+      @Override public boolean contains(Object o) {
         if (!(o instanceof Entry)) {
           return false;
         }
@@ -1837,7 +1852,7 @@
         return v != null && strategy.equalValues(v, e.getValue());
       }
 
-      public boolean remove(Object o) {
+      @Override public boolean remove(Object o) {
         if (!(o instanceof Entry)) {
           return false;
         }
@@ -1850,11 +1865,11 @@
         return Impl.this.size();
       }
 
-      public boolean isEmpty() {
+      @Override public boolean isEmpty() {
         return Impl.this.isEmpty();
       }
 
-      public void clear() {
+      @Override public void clear() {
         Impl.this.clear();
       }
     }
@@ -1963,7 +1978,7 @@
 
     static final long serialVersionUID = 0;
 
-    final ComputingStrategy<K, V, E> strategy;
+    final ComputingStrategy<K, V, E> computingStrategy;
     final Function<? super K, ? extends V> computer;
 
     /**
@@ -1973,12 +1988,11 @@
     ComputingImpl(ComputingStrategy<K, V, E> strategy, Builder builder,
         Function<? super K, ? extends V> computer) {
       super(strategy, builder);
-      this.strategy = strategy;
+      this.computingStrategy = strategy;
       this.computer = computer;
     }
 
-    @Override
-    public V get(Object k) {
+    @Override public V get(Object k) {
       /*
        * This cast isn't safe, but we can rely on the fact that K is almost
        * always passed to Map.get(), and tools like IDEs and Findbugs can
@@ -2016,7 +2030,7 @@
               int index = hash & (table.length() - 1);
               E first = table.get(index);
               ++segment.modCount;
-              entry = strategy.newEntry(key, hash, first);
+              entry = computingStrategy.newEntry(key, hash, first);
               table.set(index, entry);
               segment.count = count; // write-volatile
             }
@@ -2028,7 +2042,7 @@
             // This thread solely created the entry.
             boolean success = false;
             try {
-              V value = strategy.compute(key, entry, computer);
+              V value = computingStrategy.compute(key, entry, computer);
               if (value == null) {
                 throw new NullPointerException(
                     "compute() returned null unexpectedly");
@@ -2048,7 +2062,7 @@
         try {
           while (true) {
             try {
-              V value = strategy.waitForValue(entry);
+              V value = computingStrategy.waitForValue(entry);
               if (value == null) {
                 // Purge entry and try again.
                 segment.removeEntry(entry, hash);
@@ -2067,47 +2081,81 @@
       }
     }
   }
-}
 
-class SimpleEntry<K, V> implements Map.Entry<K, V> {
-
-  final K key;
-  V value;
-
-  SimpleEntry(K key, V value) {
-    this.key = key;
-    this.value = value;
+  /**
+   * A basic, no-frills implementation of {@code Strategy} using {@link
+   * SimpleInternalEntry}. Intended to be subclassed to provide customized
+   * behavior. For example, the following creates a map that uses byte arrays as
+   * keys: <pre>   {@code
+   *
+   *   return new CustomConcurrentHashMap.Builder().buildMap(
+   *       new SimpleStrategy<byte[], V>() {
+   *         public int hashKey(Object key) {
+   *           return Arrays.hashCode((byte[]) key);
+   *         }
+   *         public boolean equalKeys(byte[] a, Object b) {
+   *           return Arrays.equals(a, (byte[]) b);
+   *         }
+   *       });}</pre>
+   *
+   * With nothing overridden, it yields map behavior equivalent to that of
+   * {@link ConcurrentHashMap}.
+   */
+  static class SimpleStrategy<K, V>
+      implements Strategy<K, V, SimpleInternalEntry<K, V>> {
+    public SimpleInternalEntry<K, V> newEntry(
+        K key, int hash, SimpleInternalEntry<K, V> next) {
+      return new SimpleInternalEntry<K, V>(key, hash, null, next);
+    }
+    public SimpleInternalEntry<K, V> copyEntry(K key,
+        SimpleInternalEntry<K, V> original, SimpleInternalEntry<K, V> next) {
+      return new SimpleInternalEntry<K, V>(
+          key, original.hash, original.value, next);
+    }
+    public void setValue(SimpleInternalEntry<K, V> entry, V value) {
+      entry.value = value;
+    }
+    public V getValue(SimpleInternalEntry<K, V> entry) {
+      return entry.value;
+    }
+    public boolean equalKeys(K a, Object b) {
+      return a.equals(b);
+    }
+    public boolean equalValues(V a, Object b) {
+      return a.equals(b);
+    }
+    public int hashKey(Object key) {
+      return key.hashCode();
+    }
+    public K getKey(SimpleInternalEntry<K, V> entry) {
+      return entry.key;
+    }
+    public SimpleInternalEntry<K, V> getNext(SimpleInternalEntry<K, V> entry) {
+      return entry.next;
+    }
+    public int getHash(SimpleInternalEntry<K, V> entry) {
+      return entry.hash;
+    }
+    public void setInternals(
+        Internals<K, V, SimpleInternalEntry<K, V>> internals) {
+      // ignore?
+    }
   }
 
-  public K getKey() {
-    return key;
-  }
-
-  public V getValue() {
-    return value;
-  }
-
-  public V setValue(V v) {
-    V old = value;
-    value = v;
-    return old;
-  }
-
-  @Override
-  public int hashCode() {
-    return (getKey() == null ? 0 : getKey().hashCode()) ^
-      (getValue() == null ? 0 : getValue().hashCode());
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (!(o instanceof Map.Entry)) {
-      return false;
+  /**
+   * A basic, no-frills entry class used by {@link SimpleInternalEntry}.
+   */
+  static class SimpleInternalEntry<K, V> {
+    final K key;
+    final int hash;
+    final SimpleInternalEntry<K, V> next;
+    volatile V value;
+    SimpleInternalEntry(
+        K key, int hash, @Nullable V value, SimpleInternalEntry<K, V> next) {
+      this.key = key;
+      this.hash = hash;
+      this.value = value;
+      this.next = next;
     }
-
-    Map.Entry e = (Map.Entry) o;
-    return (getKey()==null ?
-          e.getKey()==null : getKey().equals(e.getKey())) &&
-         (getValue()==null ? e.getValue()==null : getValue().equals(e.getValue()));
   }
-}
\ No newline at end of file
+}
Index: src/com/google/inject/internal/ComputationException.java
===================================================================
--- src/com/google/inject/internal/ComputationException.java	(revision 929)
+++ src/com/google/inject/internal/ComputationException.java	(working copy)
@@ -20,8 +20,8 @@
  * Wraps an exception that occured during a computation.
  */
 public class ComputationException extends RuntimeException {
-
   public ComputationException(Throwable cause) {
     super(cause);
   }
+  private static final long serialVersionUID = 0;
 }
Index: src/com/google/inject/internal/Function.java
===================================================================
--- src/com/google/inject/internal/Function.java	(revision 929)
+++ src/com/google/inject/internal/Function.java	(working copy)
@@ -29,11 +29,9 @@
  *
  * <p>Implementations which may cause side effects upon evaluation are strongly
  * encouraged to state this fact clearly in their API documentation.
- * 
- * <p>This interface may be used with the Google Web Toolkit (GWT).
  *
  * @param <F> the type of the function input
- * @param <T> the type of the function output 
+ * @param <T> the type of the function output
  * @author Kevin Bourrillion
  * @author Scott Bonneau
  */
@@ -43,7 +41,7 @@
    * Applies the function to an object of type {@code F}, resulting in an object
    * of type {@code T}.  Note that types {@code F} and {@code T} may or may not
    * be the same.
-   * 
+   *
    * @param from the source object
    * @return the resulting object
    */
Index: src/com/google/inject/internal/FinalizablePhantomReference.java
===================================================================
--- src/com/google/inject/internal/FinalizablePhantomReference.java	(revision 929)
+++ src/com/google/inject/internal/FinalizablePhantomReference.java	(working copy)
@@ -41,5 +41,6 @@
   protected FinalizablePhantomReference(T referent,
       FinalizableReferenceQueue queue) {
     super(referent, queue.queue);
+    queue.cleanUp();
   }
 }
