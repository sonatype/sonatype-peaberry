Index: common.xml
===================================================================
--- common.xml  (revision 422)
+++ common.xml  (working copy)
@@ -11,6 +11,7 @@
   <target name="compile" description="Compile Java source.">
     <mkdir dir="${build.dir}/classes"/>
     <javac srcdir="${src.dir}"
+         sourcepath="${commands.src.dir}"
          debug="on"
          destdir="${build.dir}/classes">
       <classpath refid="compile.classpath"/>
Index: src/com/google/inject/Binder.java
===================================================================
--- src/com/google/inject/Binder.java	(revision 390)
+++ src/com/google/inject/Binder.java	(working copy)
@@ -20,6 +20,7 @@
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.matcher.Matcher;
+import com.google.inject.spi.Dependency;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;
 import java.lang.annotation.Annotation;
@@ -225,6 +226,16 @@
   AnnotatedConstantBindingBuilder bindConstant();
 
   /**
+   * Binds a binding factory to missing dependencies matched by a matcher.
+   *
+   * @param dependencyMatcher matches missing dependencies the binding factory
+   *     should attempt to satisfy. For example: {@code any()}.
+   * @param bindingFactory factory that can produce bindings on request
+   */
+  void bind(Matcher<? super Dependency<?>> dependencyMatcher,
+      BindingFactory<?> bindingFactory);
+
+  /**
    * Upon successful creation, the {@link Injector} will inject static fields
    * and methods in the given classes.
    *
Index: src/com/google/inject/InjectorImpl.java
===================================================================
--- src/com/google/inject/InjectorImpl.java	(revision 390)
+++ src/com/google/inject/InjectorImpl.java	(working copy)
@@ -94,6 +94,8 @@
 
   ErrorHandler errorHandler = new InvalidErrorHandler();
 
+  MissingDependencyHandler missingDependencyHandler;
+
   InjectorImpl(Injector parentInjector) {
     this.parentInjector = parentInjector;
   }
@@ -174,6 +176,10 @@
     this.errorHandler = errorHandler;
   }
 
+  void setMissingDependencyHandler(MissingDependencyHandler dependencyHandler) {
+    this.missingDependencyHandler = dependencyHandler;
+  }
+
   /**
    * Gets a binding implementation.  First, it check to see if the parent has
    * a binding.  If the parent has a binding and the binding is scoped, it
@@ -874,20 +880,31 @@
 
       final Key<?> key = Key.get(
           field.getGenericType(), field, field.getAnnotations(), errorHandler);
-      factory = SourceProviders.withDefault(StackTraceElements.forMember(field),
+      Object source = StackTraceElements.forMember(field);
+      Callable<InternalFactory<?>> lookupCall =
         new Callable<InternalFactory<?>>() {
           public InternalFactory<?> call() throws Exception {
             return injector.getInternalFactory(key);
           }
-        }
-      );
+        };
 
+      InternalFactory<?> factory =
+          SourceProviders.withDefault(source, lookupCall);
+
+      this.injectionPoint = InjectionPoint.newInstance(field,
+          Nullability.forAnnotations(field.getAnnotations()), key, injector);
+
+      // try to handle missing dependencies and check again...
+      if (null == factory && null != missingDependencyHandler &&
+          missingDependencyHandler.handle(injectionPoint)) {
+        factory = SourceProviders.withDefault(source, lookupCall);
+      }
+
       if (factory == null) {
         throw new MissingDependencyException(key, field);
       }
 
-      this.injectionPoint = InjectionPoint.newInstance(field,
-          Nullability.forAnnotations(field.getAnnotations()), key, injector);
+      this.factory = factory;
     }
 
     public Collection<Dependency<?>> getDependencies() {
@@ -951,21 +968,30 @@
   <T> SingleParameterInjector<T> createParameterInjector(
       final Key<T> key, Member member, int index, Annotation[] annotations)
       throws MissingDependencyException {
-    InternalFactory<? extends T> factory =
-        SourceProviders.withDefault(StackTraceElements.forMember(member),
+    Object source = StackTraceElements.forMember(member);
+    Callable<InternalFactory<? extends T>> lookupCall =
       new Callable<InternalFactory<? extends T>>() {
         public InternalFactory<? extends T> call() throws Exception {
           return getInternalFactory(key);
         }
-      }
-    );
+      };
 
+    InternalFactory<? extends T> factory =
+        SourceProviders.withDefault(source, lookupCall);
+
+    InjectionPoint<T> injectionPoint = InjectionPoint.newInstance(
+        member, index, Nullability.forAnnotations(annotations), key, this);
+
+    // try to handle missing dependencies and check again...
+    if (null == factory && null != missingDependencyHandler &&
+        missingDependencyHandler.handle(injectionPoint)) {
+      factory = SourceProviders.withDefault(source, lookupCall);
+    }
+
     if (factory == null) {
       throw new MissingDependencyException(key, member);
     }
 
-    InjectionPoint<T> injectionPoint = InjectionPoint.newInstance(
-        member, index, Nullability.forAnnotations(annotations), key, this);
     return new SingleParameterInjector<T>(injectionPoint, factory);
   }
 
Index: src/com/google/inject/BindingFactory.java
===================================================================
--- src/com/google/inject/BindingFactory.java	(revision 0)
+++ src/com/google/inject/BindingFactory.java	(revision 0)
@@ -0,0 +1,41 @@
+/**
+ * Copyright (C) 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject;
+
+import com.google.inject.binder.LinkedBindingBuilder;
+import com.google.inject.spi.Dependency;
+
+/**
+ * A factory capable of supplying bindings on request during construction of
+ * the {@code Injector}. Binding factories can be used to integrate service
+ * registries with Guice.
+ *
+ * @author stuart.mcculloch@jayway.net (Stuart McCulloch)
+ */
+public interface BindingFactory<B> {
+
+  /**
+   * Supplies bindings for missing dependencies that extend {@code B}
+   * 
+   * @param <T> a type of dependency this factory can supply
+   * @param dependency the missing dependency that needs a binding
+   * @param linkedBindingBuilder a partially constructed binding
+   * @return true if this factory could supply a binding
+   */
+  <T extends B> boolean bind(Dependency<T> dependency,
+      LinkedBindingBuilder<T> linkedBindingBuilder);
+}

Property changes on: src/com/google/inject/BindingFactory.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: src/com/google/inject/MissingDependencyHandler.java
===================================================================
--- src/com/google/inject/MissingDependencyHandler.java	(revision 0)
+++ src/com/google/inject/MissingDependencyHandler.java	(revision 0)
@@ -0,0 +1,32 @@
+/**
+ * Copyright (C) 2007 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject;
+
+import com.google.inject.spi.Dependency;
+
+/**
+ * Handles missing dependencies in the Injector.
+ *
+ * @author stuart.mcculloch@jayway.net (Stuart McCulloch)
+ */
+interface MissingDependencyHandler {
+
+  /**
+   * Handles a missing dependency.
+   */
+  boolean handle(Dependency<?> dependency);
+}

Property changes on: src/com/google/inject/MissingDependencyHandler.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: src/com/google/inject/AbstractModule.java
===================================================================
--- src/com/google/inject/AbstractModule.java	(revision 390)
+++ src/com/google/inject/AbstractModule.java	(working copy)
@@ -21,6 +21,7 @@
 import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.internal.Objects;
 import com.google.inject.matcher.Matcher;
+import com.google.inject.spi.Dependency;
 import com.google.inject.spi.SourceProviders;
 import com.google.inject.spi.TypeConverter;
 import java.lang.annotation.Annotation;
@@ -120,6 +121,14 @@
   }
 
   /**
+   * @see Binder#bind(Matcher, BindingFactory)
+   */
+  protected void bind(Matcher<? super Dependency<?>> dependencyMatcher,
+      BindingFactory<?> bindingFactory) {
+    binder.bind(dependencyMatcher, bindingFactory);
+  }
+
+  /**
    * @see Binder#install(Module)
    */
   protected void install(Module module) {
